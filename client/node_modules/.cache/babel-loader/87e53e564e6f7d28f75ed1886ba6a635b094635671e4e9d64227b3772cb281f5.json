{"ast":null,"code":"export {};","map":{"version":3,"names":[],"sources":["C:\\Users\\samka\\OneDrive\\Bureau\\My-Mern-Backend\\client\\node_modules\\rxjs\\src\\internal\\types.ts"],"sourcesContent":["// https://github.com/microsoft/TypeScript/issues/40462#issuecomment-689879308\r\n/// <reference lib=\"esnext.asynciterable\" />\r\n\r\nimport { Observable } from './Observable';\r\nimport { Subscription } from './Subscription';\r\n\r\n/**\r\n * Note: This will add Symbol.observable globally for all TypeScript users,\r\n * however, we are no longer polyfilling Symbol.observable\r\n */\r\ndeclare global {\r\n  interface SymbolConstructor {\r\n    readonly observable: symbol;\r\n  }\r\n}\r\n\r\n/* OPERATOR INTERFACES */\r\n\r\n/**\r\n * A function type interface that describes a function that accepts one parameter `T`\r\n * and returns another parameter `R`.\r\n *\r\n * Usually used to describe {@link OperatorFunction} - it always takes a single\r\n * parameter (the source Observable) and returns another Observable.\r\n */\r\nexport interface UnaryFunction<T, R> {\r\n  (source: T): R;\r\n}\r\n\r\nexport interface OperatorFunction<T, R> extends UnaryFunction<Observable<T>, Observable<R>> {}\r\n\r\nexport type FactoryOrValue<T> = T | (() => T);\r\n\r\nexport interface MonoTypeOperatorFunction<T> extends OperatorFunction<T, T> {}\r\n\r\n/**\r\n * A value and the time at which it was emitted.\r\n *\r\n * Emitted by the `timestamp` operator\r\n *\r\n * @see {@link timestamp}\r\n */\r\nexport interface Timestamp<T> {\r\n  value: T;\r\n  /**\r\n   * The timestamp. By default, this is in epoch milliseconds.\r\n   * Could vary based on the timestamp provider passed to the operator.\r\n   */\r\n  timestamp: number;\r\n}\r\n\r\n/**\r\n * A value emitted and the amount of time since the last value was emitted.\r\n *\r\n * Emitted by the `timeInterval` operator.\r\n *\r\n * @see {@link timeInterval}\r\n */\r\nexport interface TimeInterval<T> {\r\n  value: T;\r\n\r\n  /**\r\n   * The amount of time between this value's emission and the previous value's emission.\r\n   * If this is the first emitted value, then it will be the amount of time since subscription\r\n   * started.\r\n   */\r\n  interval: number;\r\n}\r\n\r\n/* SUBSCRIPTION INTERFACES */\r\n\r\nexport interface Unsubscribable {\r\n  unsubscribe(): void;\r\n}\r\n\r\nexport type TeardownLogic = Subscription | Unsubscribable | (() => void) | void;\r\n\r\nexport interface SubscriptionLike extends Unsubscribable {\r\n  unsubscribe(): void;\r\n  readonly closed: boolean;\r\n}\r\n\r\n/**\r\n * @deprecated Do not use. Most likely you want to use `ObservableInput`. Will be removed in v8.\r\n */\r\nexport type SubscribableOrPromise<T> = Subscribable<T> | Subscribable<never> | PromiseLike<T> | InteropObservable<T>;\r\n\r\n/** OBSERVABLE INTERFACES */\r\n\r\nexport interface Subscribable<T> {\r\n  subscribe(observer: Partial<Observer<T>>): Unsubscribable;\r\n}\r\n\r\n/**\r\n * Valid types that can be converted to observables.\r\n */\r\nexport type ObservableInput<T> =\r\n  | Observable<T>\r\n  | InteropObservable<T>\r\n  | AsyncIterable<T>\r\n  | PromiseLike<T>\r\n  | ArrayLike<T>\r\n  | Iterable<T>\r\n  | ReadableStreamLike<T>;\r\n\r\n/**\r\n * @deprecated Renamed to {@link InteropObservable }. Will be removed in v8.\r\n */\r\nexport type ObservableLike<T> = InteropObservable<T>;\r\n\r\n/**\r\n * An object that implements the `Symbol.observable` interface.\r\n */\r\nexport interface InteropObservable<T> {\r\n  [Symbol.observable]: () => Subscribable<T>;\r\n}\r\n\r\n/* NOTIFICATIONS */\r\n\r\n/**\r\n * A notification representing a \"next\" from an observable.\r\n * Can be used with {@link dematerialize}.\r\n */\r\nexport interface NextNotification<T> {\r\n  /** The kind of notification. Always \"N\" */\r\n  kind: 'N';\r\n  /** The value of the notification. */\r\n  value: T;\r\n}\r\n\r\n/**\r\n * A notification representing an \"error\" from an observable.\r\n * Can be used with {@link dematerialize}.\r\n */\r\nexport interface ErrorNotification {\r\n  /** The kind of notification. Always \"E\" */\r\n  kind: 'E';\r\n  error: any;\r\n}\r\n\r\n/**\r\n * A notification representing a \"completion\" from an observable.\r\n * Can be used with {@link dematerialize}.\r\n */\r\nexport interface CompleteNotification {\r\n  kind: 'C';\r\n}\r\n\r\n/**\r\n * Valid observable notification types.\r\n */\r\nexport type ObservableNotification<T> = NextNotification<T> | ErrorNotification | CompleteNotification;\r\n\r\n/* OBSERVER INTERFACES */\r\n\r\nexport interface NextObserver<T> {\r\n  closed?: boolean;\r\n  next: (value: T) => void;\r\n  error?: (err: any) => void;\r\n  complete?: () => void;\r\n}\r\n\r\nexport interface ErrorObserver<T> {\r\n  closed?: boolean;\r\n  next?: (value: T) => void;\r\n  error: (err: any) => void;\r\n  complete?: () => void;\r\n}\r\n\r\nexport interface CompletionObserver<T> {\r\n  closed?: boolean;\r\n  next?: (value: T) => void;\r\n  error?: (err: any) => void;\r\n  complete: () => void;\r\n}\r\n\r\nexport type PartialObserver<T> = NextObserver<T> | ErrorObserver<T> | CompletionObserver<T>;\r\n\r\n/**\r\n * An object interface that defines a set of callback functions a user can use to get\r\n * notified of any set of {@link Observable}\r\n * {@link guide/glossary-and-semantics#notification notification} events.\r\n *\r\n * For more info, please refer to {@link guide/observer this guide}.\r\n */\r\nexport interface Observer<T> {\r\n  /**\r\n   * A callback function that gets called by the producer during the subscription when\r\n   * the producer \"has\" the `value`. It won't be called if `error` or `complete` callback\r\n   * functions have been called, nor after the consumer has unsubscribed.\r\n   *\r\n   * For more info, please refer to {@link guide/glossary-and-semantics#next this guide}.\r\n   */\r\n  next: (value: T) => void;\r\n  /**\r\n   * A callback function that gets called by the producer if and when it encountered a\r\n   * problem of any kind. The errored value will be provided through the `err` parameter.\r\n   * This callback can't be called more than one time, it can't be called if the\r\n   * `complete` callback function have been called previously, nor it can't be called if\r\n   * the consumer has unsubscribed.\r\n   *\r\n   * For more info, please refer to {@link guide/glossary-and-semantics#error this guide}.\r\n   */\r\n  error: (err: any) => void;\r\n  /**\r\n   * A callback function that gets called by the producer if and when it has no more\r\n   * values to provide (by calling `next` callback function). This means that no error\r\n   * has happened. This callback can't be called more than one time, it can't be called\r\n   * if the `error` callback function have been called previously, nor it can't be called\r\n   * if the consumer has unsubscribed.\r\n   *\r\n   * For more info, please refer to {@link guide/glossary-and-semantics#complete this guide}.\r\n   */\r\n  complete: () => void;\r\n}\r\n\r\nexport interface SubjectLike<T> extends Observer<T>, Subscribable<T> {}\r\n\r\n/* SCHEDULER INTERFACES */\r\n\r\nexport interface SchedulerLike extends TimestampProvider {\r\n  schedule<T>(work: (this: SchedulerAction<T>, state: T) => void, delay: number, state: T): Subscription;\r\n  schedule<T>(work: (this: SchedulerAction<T>, state?: T) => void, delay: number, state?: T): Subscription;\r\n  schedule<T>(work: (this: SchedulerAction<T>, state?: T) => void, delay?: number, state?: T): Subscription;\r\n}\r\n\r\nexport interface SchedulerAction<T> extends Subscription {\r\n  schedule(state?: T, delay?: number): Subscription;\r\n}\r\n\r\n/**\r\n * This is a type that provides a method to allow RxJS to create a numeric timestamp\r\n */\r\nexport interface TimestampProvider {\r\n  /**\r\n   * Returns a timestamp as a number.\r\n   *\r\n   * This is used by types like `ReplaySubject` or operators like `timestamp` to calculate\r\n   * the amount of time passed between events.\r\n   */\r\n  now(): number;\r\n}\r\n\r\n/**\r\n * Extracts the type from an `ObservableInput<any>`. If you have\r\n * `O extends ObservableInput<any>` and you pass in `Observable<number>`, or\r\n * `Promise<number>`, etc, it will type as `number`.\r\n */\r\nexport type ObservedValueOf<O> = O extends ObservableInput<infer T> ? T : never;\r\n\r\n/**\r\n * Extracts a union of element types from an `ObservableInput<any>[]`.\r\n * If you have `O extends ObservableInput<any>[]` and you pass in\r\n * `Observable<string>[]` or `Promise<string>[]` you would get\r\n * back a type of `string`.\r\n * If you pass in `[Observable<string>, Observable<number>]` you would\r\n * get back a type of `string | number`.\r\n */\r\nexport type ObservedValueUnionFromArray<X> = X extends Array<ObservableInput<infer T>> ? T : never;\r\n\r\n/**\r\n * @deprecated Renamed to {@link ObservedValueUnionFromArray}. Will be removed in v8.\r\n */\r\nexport type ObservedValuesFromArray<X> = ObservedValueUnionFromArray<X>;\r\n\r\n/**\r\n * Extracts a tuple of element types from an `ObservableInput<any>[]`.\r\n * If you have `O extends ObservableInput<any>[]` and you pass in\r\n * `[Observable<string>, Observable<number>]` you would get back a type\r\n * of `[string, number]`.\r\n */\r\nexport type ObservedValueTupleFromArray<X> = { [K in keyof X]: ObservedValueOf<X[K]> };\r\n\r\n/**\r\n * Used to infer types from arguments to functions like {@link forkJoin}.\r\n * So that you can have `forkJoin([Observable<A>, PromiseLike<B>]): Observable<[A, B]>`\r\n * et al.\r\n */\r\nexport type ObservableInputTuple<T> = {\r\n  [K in keyof T]: ObservableInput<T[K]>;\r\n};\r\n\r\n/**\r\n * Constructs a new tuple with the specified type at the head.\r\n * If you declare `Cons<A, [B, C]>` you will get back `[A, B, C]`.\r\n */\r\nexport type Cons<X, Y extends readonly any[]> = ((arg: X, ...rest: Y) => any) extends (...args: infer U) => any ? U : never;\r\n\r\n/**\r\n * Extracts the head of a tuple.\r\n * If you declare `Head<[A, B, C]>` you will get back `A`.\r\n */\r\nexport type Head<X extends readonly any[]> = ((...args: X) => any) extends (arg: infer U, ...rest: any[]) => any ? U : never;\r\n\r\n/**\r\n * Extracts the tail of a tuple.\r\n * If you declare `Tail<[A, B, C]>` you will get back `[B, C]`.\r\n */\r\nexport type Tail<X extends readonly any[]> = ((...args: X) => any) extends (arg: any, ...rest: infer U) => any ? U : never;\r\n\r\n/**\r\n * Extracts the generic value from an Array type.\r\n * If you have `T extends Array<any>`, and pass a `string[]` to it,\r\n * `ValueFromArray<T>` will return the actual type of `string`.\r\n */\r\nexport type ValueFromArray<A extends readonly unknown[]> = A extends Array<infer T> ? T : never;\r\n\r\n/**\r\n * Gets the value type from an {@link ObservableNotification}, if possible.\r\n */\r\nexport type ValueFromNotification<T> = T extends { kind: 'N' | 'E' | 'C' }\r\n  ? T extends NextNotification<any>\r\n    ? T extends { value: infer V }\r\n      ? V\r\n      : undefined\r\n    : never\r\n  : never;\r\n\r\n/**\r\n * A simple type to represent a gamut of \"falsy\" values... with a notable exception:\r\n * `NaN` is \"falsy\" however, it is not and cannot be typed via TypeScript. See\r\n * comments here: https://github.com/microsoft/TypeScript/issues/28682#issuecomment-707142417\r\n */\r\nexport type Falsy = null | undefined | false | 0 | -0 | 0n | '';\r\n\r\nexport type TruthyTypesOf<T> = T extends Falsy ? never : T;\r\n\r\n// We shouldn't rely on this type definition being available globally yet since it's\r\n// not necessarily available in every TS environment.\r\ninterface ReadableStreamDefaultReaderLike<T> {\r\n  // HACK: As of TS 4.2.2, The provided types for the iterator results of a `ReadableStreamDefaultReader`\r\n  // are significantly different enough from `IteratorResult` as to cause compilation errors.\r\n  // The type at the time is `ReadableStreamDefaultReadResult`.\r\n  read(): PromiseLike<\r\n    | {\r\n        done: false;\r\n        value: T;\r\n      }\r\n    | { done: true; value?: undefined }\r\n  >;\r\n  releaseLock(): void;\r\n}\r\n\r\n/**\r\n * The base signature RxJS will look for to identify and use\r\n * a [ReadableStream](https://streams.spec.whatwg.org/#rs-class)\r\n * as an {@link ObservableInput} source.\r\n */\r\nexport interface ReadableStreamLike<T> {\r\n  getReader(): ReadableStreamDefaultReaderLike<T>;\r\n}\r\n\r\n/**\r\n * An observable with a `connect` method that is used to create a subscription\r\n * to an underlying source, connecting it with all consumers via a multicast.\r\n */\r\nexport interface Connectable<T> extends Observable<T> {\r\n  /**\r\n   * (Idempotent) Calling this method will connect the underlying source observable to all subscribed consumers\r\n   * through an underlying {@link Subject}.\r\n   * @returns A subscription, that when unsubscribed, will \"disconnect\" the source from the connector subject,\r\n   * severing notifications to all consumers.\r\n   */\r\n  connect(): Subscription;\r\n}\r\n"],"mappings":"","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}